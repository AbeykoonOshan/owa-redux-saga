"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[301],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return k}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,c=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=s(n),k=l,m=u["".concat(c,".").concat(k)]||u[k]||d[k]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function k(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,i=new Array(o);i[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:l,i[1]=r;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9147:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return p},default:function(){return u}});var a=n(7462),l=n(3366),o=(n(7294),n(3905)),i=["components"],r={title:"Task Cancellation",hide_title:!0},c="Task cancellation",s={unversionedId:"advanced/TaskCancellation",id:"advanced/TaskCancellation",isDocsHomePage:!1,title:"Task Cancellation",description:"We saw already an example of cancellation in the Non blocking calls section. In this section we'll review cancellation in more detail.",source:"@site/../docs/advanced/TaskCancellation.md",sourceDirName:"advanced",slug:"/advanced/TaskCancellation",permalink:"/docs/advanced/TaskCancellation",editUrl:"https://github.com/redux-saga/redux-saga/edit/main/docs/../docs/advanced/TaskCancellation.md",tags:[],version:"current",frontMatter:{title:"Task Cancellation",hide_title:!0},sidebar:"docs",previous:{title:"Running Tasks In Parallel",permalink:"/docs/advanced/RunningTasksInParallel"},next:{title:"Testing",permalink:"/docs/advanced/Testing"}},p=[{value:"Testing generators with fork effect",id:"testing-generators-with-fork-effect",children:[{value:"Note",id:"note",children:[],level:3}],level:2},{value:"Automatic cancellation",id:"automatic-cancellation",children:[],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,l.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"task-cancellation"},"Task cancellation"),(0,o.kt)("p",null,"We saw already an example of cancellation in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/advanced/NonBlockingCalls"},"Non blocking calls")," section. In this section we'll review cancellation in more detail."),(0,o.kt)("p",null,"Once a task is forked, you can abort its execution using ",(0,o.kt)("inlineCode",{parentName:"p"},"yield cancel(task)"),"."),(0,o.kt)("p",null,"To see how it works, let's consider a basic example: A background sync which can be started/stopped by some UI commands. Upon receiving a ",(0,o.kt)("inlineCode",{parentName:"p"},"START_BACKGROUND_SYNC")," action, we fork a background task that will periodically sync some data from a remote server."),(0,o.kt)("p",null,"The task will execute continually until a ",(0,o.kt)("inlineCode",{parentName:"p"},"STOP_BACKGROUND_SYNC")," action is triggered. Then we cancel the background task and wait again for the next ",(0,o.kt)("inlineCode",{parentName:"p"},"START_BACKGROUND_SYNC")," action."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, put, call, fork, cancel, cancelled, delay } from 'redux-saga/effects'\nimport { someApi, actions } from 'somewhere'\n\nfunction* bgSync() {\n  try {\n    while (true) {\n      yield put(actions.requestStart())\n      const result = yield call(someApi)\n      yield put(actions.requestSuccess(result))\n      yield delay(5000)\n    }\n  } finally {\n    if (yield cancelled())\n      yield put(actions.requestFailure('Sync cancelled!'))\n  }\n}\n\nfunction* main() {\n  while ( yield take('START_BACKGROUND_SYNC') ) {\n    // starts the task in the background\n    const bgSyncTask = yield fork(bgSync)\n\n    // wait for the user stop action\n    yield take('STOP_BACKGROUND_SYNC')\n    // user clicked stop. cancel the background task\n    // this will cause the forked bgSync task to jump into its finally block\n    yield cancel(bgSyncTask)\n  }\n}\n")),(0,o.kt)("p",null,"In the above example, cancellation of ",(0,o.kt)("inlineCode",{parentName:"p"},"bgSyncTask")," will use ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return"},"Generator.prototype.return")," to make the Generator jump directly to the finally block. Here you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"yield cancelled()")," to check if the Generator has been cancelled or not."),(0,o.kt)("p",null,"Cancelling a running task will also cancel the current Effect where the task is blocked at the moment of cancellation."),(0,o.kt)("p",null,"For example, suppose that at a certain point in an application's lifetime, we have this pending call chain:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function* main() {\n  const task = yield fork(subtask)\n  ...\n  // later\n  yield cancel(task)\n}\n\nfunction* subtask() {\n  ...\n  yield call(subtask2) // currently blocked on this call\n  ...\n}\n\nfunction* subtask2() {\n  ...\n  yield call(someApi) // currently blocked on this call\n  ...\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"yield cancel(task)")," triggers a cancellation on ",(0,o.kt)("inlineCode",{parentName:"p"},"subtask"),", which in turn triggers a cancellation on ",(0,o.kt)("inlineCode",{parentName:"p"},"subtask2"),"."),(0,o.kt)("p",null,"So we saw that Cancellation propagates downward (in contrast returned values and uncaught errors propagates upward). You can see it as a ",(0,o.kt)("em",{parentName:"p"},"contract")," between the caller (which invokes the async operation) and the callee (the invoked operation). The callee is responsible for performing the operation. If it has completed (either success or error) the outcome propagates up to its caller and eventually to the caller of the caller and so on. That is, callees are responsible for ",(0,o.kt)("em",{parentName:"p"},"completing the flow"),"."),(0,o.kt)("p",null,"Now if the callee is still pending and the caller decides to cancel the operation, it triggers a kind of a signal that propagates down to the callee (and possibly to any deep operations called by the callee itself). All deeply pending operations will be cancelled."),(0,o.kt)("p",null,"There is another direction where the cancellation propagates to as well: the joiners of a task (those blocked on a ",(0,o.kt)("inlineCode",{parentName:"p"},"yield join(task)"),") will also be cancelled if the joined task is cancelled. Similarly, any potential callers of those joiners will be cancelled as well (because they are blocked on an operation that has been cancelled from outside)."),(0,o.kt)("h2",{id:"testing-generators-with-fork-effect"},"Testing generators with fork effect"),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"fork")," is called it starts the task in the background and also returns task object like we have learned previously. When testing this we have to use utility function ",(0,o.kt)("inlineCode",{parentName:"p"},"createMockTask"),". Object returned from this function should be passed to next ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," call after fork test. Mock task can then be passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"cancel")," for example. Here is test for ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," generator which is on top of this page."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createMockTask } from '@redux-saga/testing-utils';\n\ndescribe('main', () => {\n  const generator = main();\n\n  it('waits for start action', () => {\n    const expectedYield = take('START_BACKGROUND_SYNC');\n    expect(generator.next().value).to.deep.equal(expectedYield);\n  });\n\n  it('forks the service', () => {\n    const expectedYield = fork(bgSync);\n    const mockedAction = { type: 'START_BACKGROUND_SYNC' };\n    expect(generator.next(mockedAction).value).to.deep.equal(expectedYield);\n  });\n\n  it('waits for stop action and then cancels the service', () => {\n    const mockTask = createMockTask();\n\n    const expectedTakeYield = take('STOP_BACKGROUND_SYNC');\n    expect(generator.next(mockTask).value).to.deep.equal(expectedTakeYield);\n\n    const expectedCancelYield = cancel(mockTask);\n    expect(generator.next().value).to.deep.equal(expectedCancelYield);\n  });\n});\n")),(0,o.kt)("p",null,"You can use a mock task's ",(0,o.kt)("inlineCode",{parentName:"p"},"setResult"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"setError"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"cancel")," methods to control its state. For example ",(0,o.kt)("inlineCode",{parentName:"p"},"mockTask.setResult(42)")," will set its internal status to Done and any ",(0,o.kt)("inlineCode",{parentName:"p"},"join")," effect given that task will return ",(0,o.kt)("inlineCode",{parentName:"p"},"42"),"."),(0,o.kt)("p",null,"Calling ",(0,o.kt)("inlineCode",{parentName:"p"},"setResult"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"setError"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"cancel")," on a mock task after having already called one of them, trying to change its status a second time, will throw an error."),(0,o.kt)("h3",{id:"note"},"Note"),(0,o.kt)("p",null,"It's important to remember that ",(0,o.kt)("inlineCode",{parentName:"p"},"yield cancel(task)")," doesn't wait for the cancelled task to finish (i.e. to perform its finally block). The cancel effect behaves like fork. It returns as soon as the cancel was initiated. Once cancelled, a task should normally return as soon as it finishes its cleanup logic."),(0,o.kt)("h2",{id:"automatic-cancellation"},"Automatic cancellation"),(0,o.kt)("p",null,"Besides manual cancellation there are cases where cancellation is triggered automatically"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In a ",(0,o.kt)("inlineCode",{parentName:"p"},"race")," effect. All race competitors, except the winner, are automatically cancelled.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In a parallel effect (",(0,o.kt)("inlineCode",{parentName:"p"},"yield all([...])"),"). The parallel effect is rejected as soon as one of the sub-effects is rejected (as implied by ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise.all"),"). In this case, all the other sub-effects are automatically cancelled."))))}u.isMDXComponent=!0}}]);