"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[692],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return h}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(t),h=r,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||i;return t?a.createElement(m,o(o({ref:n},c),{},{components:t})):a.createElement(m,o({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9402:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return u}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),o=["components"],l={id:"recipes",title:"Recipes",hide_title:!0},p="Recipes",s={unversionedId:"recipes",id:"recipes",isDocsHomePage:!1,title:"Recipes",description:"Throttling",source:"@site/../docs/Recipes.md",sourceDirName:".",slug:"/recipes",permalink:"/docs/recipes",editUrl:"https://github.com/redux-saga/redux-saga/edit/main/docs/../docs/Recipes.md",tags:[],version:"current",frontMatter:{id:"recipes",title:"Recipes",hide_title:!0},sidebar:"docs",previous:{title:"Using Run Saga",permalink:"/docs/advanced/UsingRunSaga"},next:{title:"External Resources",permalink:"/docs/ExternalResources"}},c=[{value:"Throttling",id:"throttling",children:[],level:2},{value:"Debouncing",id:"debouncing",children:[],level:2},{value:"Retrying XHR calls",id:"retrying-xhr-calls",children:[],level:2},{value:"Undo",id:"undo",children:[],level:2}],d={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"recipes"},"Recipes"),(0,i.kt)("h2",{id:"throttling"},"Throttling"),(0,i.kt)("p",null,"You can throttle a sequence of dispatched actions by using a handy built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"throttle")," helper. For example, suppose the UI fires an ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUT_CHANGED")," action while the user is typing in a text field."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { throttle } from 'redux-saga/effects'\n\nfunction* handleInput(input) {\n  // ...\n}\n\nfunction* watchInput() {\n  yield throttle(500, 'INPUT_CHANGED', handleInput)\n}\n")),(0,i.kt)("p",null,"By using this helper the ",(0,i.kt)("inlineCode",{parentName:"p"},"watchInput")," won't start a new ",(0,i.kt)("inlineCode",{parentName:"p"},"handleInput")," task for 500ms, but in the same time it will still be accepting the latest ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUT_CHANGED")," actions into its underlaying ",(0,i.kt)("inlineCode",{parentName:"p"},"buffer"),", so it'll miss all ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUT_CHANGED")," actions happening in-between. This ensures that the Saga will take at most one ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUT_CHANGED")," action during each period of 500ms and still be able to process trailing action."),(0,i.kt)("h2",{id:"debouncing"},"Debouncing"),(0,i.kt)("p",null,"From redux-saga@v1 ",(0,i.kt)("a",{parentName:"p",href:"/docs/api#debouncems-pattern-saga-args"},"debounce")," is built-in effect."),(0,i.kt)("p",null,"Let's consider how the effect could be implemented as a combination of other base effects."),(0,i.kt)("p",null,"To debounce a sequence, put the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," helper in the forked task:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"\nimport { call, cancel, fork, take, delay } from 'redux-saga/effects'\n\nfunction* handleInput(input) {\n  // debounce by 500ms\n  yield delay(500)\n  ...\n}\n\nfunction* watchInput() {\n  let task\n  while (true) {\n    const { input } = yield take('INPUT_CHANGED')\n    if (task) {\n      yield cancel(task)\n    }\n    task = yield fork(handleInput, input)\n  }\n}\n")),(0,i.kt)("p",null,"In the above example ",(0,i.kt)("inlineCode",{parentName:"p"},"handleInput")," waits for 500ms before performing its logic. If the user types something during this period we'll get more ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUT_CHANGED")," actions. Since ",(0,i.kt)("inlineCode",{parentName:"p"},"handleInput")," will still be blocked in the ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," call, it'll be cancelled by ",(0,i.kt)("inlineCode",{parentName:"p"},"watchInput")," before it can start performing its logic."),(0,i.kt)("p",null,"Example above could be rewritten with redux-saga ",(0,i.kt)("inlineCode",{parentName:"p"},"takeLatest")," helper:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"\nimport { call, takeLatest, delay } from 'redux-saga/effects'\n\nfunction* handleInput({ input }) {\n  // debounce by 500ms\n  yield delay(500)\n  ...\n}\n\nfunction* watchInput() {\n  // will cancel current running handleInput task\n  yield takeLatest('INPUT_CHANGED', handleInput);\n}\n")),(0,i.kt)("h2",{id:"retrying-xhr-calls"},"Retrying XHR calls"),(0,i.kt)("p",null,"From redux-saga@v1 ",(0,i.kt)("a",{parentName:"p",href:"/docs/api#retrymaxtries-delay-fn-args"},"retry")," is built-in effect."),(0,i.kt)("p",null,"Let's consider how the effect could be implemented as a combination of other base effects."),(0,i.kt)("p",null,"To retry an XHR call for a specific amount of times, use a for loop with a delay:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { call, put, take, delay } from 'redux-saga/effects'\n\nfunction* updateApi(data) {\n  for (let i = 0; i < 5; i++) {\n    try {\n      const apiResponse = yield call(apiRequest, { data })\n      return apiResponse\n    } catch (err) {\n      if (i < 4) {\n        yield delay(2000)\n      }\n    }\n  }\n  // attempts failed after 5 attempts\n  throw new Error('API request failed')\n}\n\nexport default function* updateResource() {\n  while (true) {\n    const { data } = yield take('UPDATE_START')\n    try {\n      const apiResponse = yield call(updateApi, data)\n      yield put({\n        type: 'UPDATE_SUCCESS',\n        payload: apiResponse.body,\n      })\n    } catch (error) {\n      yield put({\n        type: 'UPDATE_ERROR',\n        error,\n      })\n    }\n  }\n}\n")),(0,i.kt)("p",null,"In the above example the ",(0,i.kt)("inlineCode",{parentName:"p"},"apiRequest")," will be retried for 5 times, with a delay of 2 seconds in between. After the 5th failure, the exception thrown will get caught by the parent saga, which will dispatch the ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE_ERROR")," action."),(0,i.kt)("p",null,"If you want unlimited retries, then the ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop can be replaced with a ",(0,i.kt)("inlineCode",{parentName:"p"},"while (true)"),". Also instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"take")," you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"takeLatest"),", so only the last request will be retried. By adding an ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE_RETRY")," action in the error handling, we can inform the user that the update was not successful but it will be retried."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { delay } from 'redux-saga/effects'\n\nfunction* updateApi(data) {\n  while (true) {\n    try {\n      const apiResponse = yield call(apiRequest, { data })\n      return apiResponse\n    } catch (error) {\n      yield put({\n        type: 'UPDATE_RETRY',\n        error,\n      })\n      yield delay(2000)\n    }\n  }\n}\n\nfunction* updateResource({ data }) {\n  const apiResponse = yield call(updateApi, data)\n  yield put({\n    type: 'UPDATE_SUCCESS',\n    payload: apiResponse.body,\n  })\n}\n\nexport function* watchUpdateResource() {\n  yield takeLatest('UPDATE_START', updateResource)\n}\n")),(0,i.kt)("h2",{id:"undo"},"Undo"),(0,i.kt)("p",null,"The ability to undo respects the user by allowing the action to happen smoothly\nfirst and foremost before assuming they don't know what they are doing (",(0,i.kt)("a",{parentName:"p",href:"https://goodui.org/#8"},"link"),").\nThe ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/recipes/implementing-undo-history#understanding-undo-history"},"redux documentation")," describes a\nrobust way to implement an undo based on modifying the reducer to contain ",(0,i.kt)("inlineCode",{parentName:"p"},"past"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"present"),",\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"future")," state. There is even a library ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/omnidan/redux-undo"},"redux-undo")," that\ncreates a higher order reducer to do most of the heavy lifting for the developer."),(0,i.kt)("p",null,"However, this method comes with overhead because it stores references to the previous state(s) of the application."),(0,i.kt)("p",null,"Using redux-saga's ",(0,i.kt)("inlineCode",{parentName:"p"},"delay")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"race")," we can implement a basic, one-time undo without enhancing\nour reducer or storing the previous state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, put, call, spawn, race, delay } from 'redux-saga/effects'\nimport { updateThreadApi, actions } from 'somewhere'\n\nfunction* onArchive(action) {\n  const { threadId } = action\n  const undoId = `UNDO_ARCHIVE_${threadId}`\n\n  const thread = { id: threadId, archived: true }\n\n  // show undo UI element, and provide a key to communicate\n  yield put(actions.showUndo(undoId))\n\n  // optimistically mark the thread as `archived`\n  yield put(actions.updateThread(thread))\n\n  // allow the user 5 seconds to perform undo.\n  // after 5 seconds, 'archive' will be the winner of the race-condition\n  const { undo, archive } = yield race({\n    undo: take(action => action.type === 'UNDO' && action.undoId === undoId),\n    archive: delay(5000),\n  })\n\n  // hide undo UI element, the race condition has an answer\n  yield put(actions.hideUndo(undoId))\n\n  if (undo) {\n    // revert thread to previous state\n    yield put(actions.updateThread({ id: threadId, archived: false }))\n  } else if (archive) {\n    // make the API call to apply the changes remotely\n    yield call(updateThreadApi, thread)\n  }\n}\n\nfunction* main() {\n  while (true) {\n    // wait for an ARCHIVE_THREAD to happen\n    const action = yield take('ARCHIVE_THREAD')\n    // use spawn to execute onArchive in a non-blocking fashion, which also\n    // prevents cancellation when main saga gets cancelled.\n    // This helps us in keeping state in sync between server and client\n    yield spawn(onArchive, action)\n  }\n}\n")))}u.isMDXComponent=!0}}]);