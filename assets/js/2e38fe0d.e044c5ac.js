"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[732],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},438:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Composing Sagas",hide_title:!0},l="Composing Sagas",c={unversionedId:"advanced/ComposingSagas",id:"advanced/ComposingSagas",isDocsHomePage:!1,title:"Composing Sagas",description:"While using yield* provides an idiomatic way of composing Sagas, this approach has some limitations:",source:"@site/../docs/advanced/ComposingSagas.md",sourceDirName:"advanced",slug:"/advanced/ComposingSagas",permalink:"/docs/advanced/ComposingSagas",editUrl:"https://github.com/redux-saga/redux-saga/edit/main/docs/../docs/advanced/ComposingSagas.md",tags:[],version:"current",frontMatter:{title:"Composing Sagas",hide_title:!0},sidebar:"docs",previous:{title:"Channels",permalink:"/docs/advanced/Channels"},next:{title:"Concurrency",permalink:"/docs/advanced/Concurrency"}},u=[],p={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"composing-sagas"},"Composing Sagas"),(0,o.kt)("p",null,"While using ",(0,o.kt)("inlineCode",{parentName:"p"},"yield*")," provides an idiomatic way of composing Sagas, this approach has some limitations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"You'll likely want to test nested generators separately. This leads to some duplication in the test code as well as the overhead of the duplicated execution. We don't want to execute a nested generator but only make sure the call to it was issued with the right argument.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"More importantly, ",(0,o.kt)("inlineCode",{parentName:"p"},"yield*")," allows only for sequential composition of tasks, so you can only ",(0,o.kt)("inlineCode",{parentName:"p"},"yield*")," to one generator at a time."))),(0,o.kt)("p",null,"You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," to start one or more subtasks in parallel. When yielding a call to a generator, the Saga will wait for the generator to terminate before progressing, then resume with the returned value (or throws if an error propagates from the subtask)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function* fetchPosts() {\n  yield put(actions.requestPosts())\n  const products = yield call(fetchApi, '/products')\n  yield put(actions.receivePosts(products))\n}\n\nfunction* watchFetch() {\n  while (yield take('FETCH_POSTS')) {\n    yield call(fetchPosts) // waits for the fetchPosts task to terminate\n  }\n}\n")),(0,o.kt)("p",null,"Yielding to an array of nested generators will start all the sub-generators in parallel, wait\nfor them to finish, then resume with all the results"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function* mainSaga(getState) {\n  const results = yield all([call(task1), call(task2), ...])\n  yield put(showResults(results))\n}\n")),(0,o.kt)("p",null,"In fact, yielding Sagas is no different than yielding other effects (future actions, timeouts, etc). This means you can combine those Sagas with all the other types using the effect combinators."),(0,o.kt)("p",null,"For example, you may want the user to finish some game in a limited amount of time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function* game(getState) {\n  let finished\n  while (!finished) {\n    // has to finish in 60 seconds\n    const {score, timeout} = yield race({\n      score: call(play, getState),\n      timeout: delay(60000)\n    })\n\n    if (!timeout) {\n      finished = true\n      yield put(showScore(score))\n    }\n  }\n}\n")))}d.isMDXComponent=!0}}]);