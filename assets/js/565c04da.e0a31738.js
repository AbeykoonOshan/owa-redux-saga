"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[254],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=s(n),f=l,k=u["".concat(c,".").concat(f)]||u[f]||d[f]||r;return n?a.createElement(k,i(i({ref:t},p),{},{components:n})):a.createElement(k,i({ref:t},p))}));function f(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8430:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return p},default:function(){return u}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={title:"Fork Model",hide_title:!0},c="redux-saga's fork model",s={unversionedId:"advanced/ForkModel",id:"advanced/ForkModel",isDocsHomePage:!1,title:"Fork Model",description:"In redux-saga you can dynamically fork tasks that execute in the background using 2 Effects",source:"@site/../docs/advanced/ForkModel.md",sourceDirName:"advanced",slug:"/advanced/ForkModel",permalink:"/docs/advanced/ForkModel",editUrl:"https://github.com/redux-saga/redux-saga/edit/main/docs/../docs/advanced/ForkModel.md",tags:[],version:"current",frontMatter:{title:"Fork Model",hide_title:!0},sidebar:"docs",previous:{title:"Concurrency",permalink:"/docs/advanced/Concurrency"},next:{title:"Future Actions",permalink:"/docs/advanced/FutureActions"}},p=[{value:"Attached forks (using <code>fork</code>)",id:"attached-forks-using-fork",children:[{value:"Completion",id:"completion",children:[],level:3}],level:2},{value:"Error propagation",id:"error-propagation",children:[],level:2},{value:"Cancellation",id:"cancellation",children:[],level:2},{value:"Detached forks (using <code>spawn</code>)",id:"detached-forks-using-spawn",children:[],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"redux-sagas-fork-model"},"redux-saga's fork model"),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"redux-saga")," you can dynamically fork tasks that execute in the background using 2 Effects"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fork")," is used to create ",(0,r.kt)("em",{parentName:"li"},"attached forks")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"spawn")," is used to create ",(0,r.kt)("em",{parentName:"li"},"detached forks"))),(0,r.kt)("h2",{id:"attached-forks-using-fork"},"Attached forks (using ",(0,r.kt)("inlineCode",{parentName:"h2"},"fork"),")"),(0,r.kt)("p",null,"Attached forks remain attached to their parent by the following rules"),(0,r.kt)("h3",{id:"completion"},"Completion"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A Saga terminates only after",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It terminates its own body of instructions"),(0,r.kt)("li",{parentName:"ul"},"All attached forks are themselves terminated")))),(0,r.kt)("p",null,"For example say we have the following"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { fork, call, put, delay } from 'redux-saga/effects'\nimport api from './somewhere/api' // app specific\nimport { receiveData } from './somewhere/actions' // app specific\n\nfunction* fetchAll() {\n  const task1 = yield fork(fetchResource, 'users')\n  const task2 = yield fork(fetchResource, 'comments')\n  yield delay(1000)\n}\n\nfunction* fetchResource(resource) {\n  const {data} = yield call(api.fetch, resource)\n  yield put(receiveData(data))\n}\n\nfunction* main() {\n  yield call(fetchAll)\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"call(fetchAll)")," will terminate after:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll")," body itself terminates, this means all 3 effects are performed. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"fork")," effects are non blocking, the\ntask will block on ",(0,r.kt)("inlineCode",{parentName:"p"},"delay(1000)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The 2 forked tasks terminate, i.e. after fetching the required resources and putting the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"receiveData")," actions"))),(0,r.kt)("p",null,"So the whole task will block until a delay of 1000 millisecond passed ",(0,r.kt)("em",{parentName:"p"},"and")," both ",(0,r.kt)("inlineCode",{parentName:"p"},"task1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"task2")," finished their business."),(0,r.kt)("p",null,"Say for example, the delay of 1000 milliseconds elapsed and the 2 tasks haven't yet finished, then ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll")," will still wait\nfor all forked tasks to finish before terminating the whole task."),(0,r.kt)("p",null,"The attentive reader might have noticed the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll")," saga could be rewritten using the parallel Effect"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function* fetchAll() {\n  yield all([\n    call(fetchResource, 'users'),     // task1\n    call(fetchResource, 'comments'),  // task2,\n    delay(1000)\n  ])\n}\n")),(0,r.kt)("p",null,"In fact, attached forks share the same semantics with the parallel Effect:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We're executing tasks in parallel"),(0,r.kt)("li",{parentName:"ul"},"The parent will terminate after all launched tasks terminate")),(0,r.kt)("p",null,"And this applies for all other semantics as well (error and cancellation propagation). You can understand how\nattached forks behave by considering it as a ",(0,r.kt)("em",{parentName:"p"},"dynamic parallel")," Effect."),(0,r.kt)("h2",{id:"error-propagation"},"Error propagation"),(0,r.kt)("p",null,"Following the same analogy, Let's examine in detail how errors are handled in parallel Effects"),(0,r.kt)("p",null,"for example, let's say we have this Effect"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"yield all([\n  call(fetchResource, 'users'),\n  call(fetchResource, 'comments'),\n  delay(1000)\n])\n")),(0,r.kt)("p",null,"The above effect will fail as soon as any one of the 3 child Effects fails. Furthermore, the uncaught error will cause\nthe parallel Effect to cancel all the other pending Effects. So for example if ",(0,r.kt)("inlineCode",{parentName:"p"},"call(fetchResource, 'users')")," raises an\nuncaught error, the parallel Effect will cancel the 2 other tasks (if they are still pending) then aborts itself with the\nsame error from the failed call."),(0,r.kt)("p",null,"Similarly for attached forks, a Saga aborts as soon as"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Its main body of instructions throws an error")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An uncaught error was raised by one of its attached forks"))),(0,r.kt)("p",null,"So in the previous example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"//... imports\n\nfunction* fetchAll() {\n  const task1 = yield fork(fetchResource, 'users')\n  const task2 = yield fork(fetchResource, 'comments')\n  yield delay(1000)\n}\n\nfunction* fetchResource(resource) {\n  const {data} = yield call(api.fetch, resource)\n  yield put(receiveData(data))\n}\n\nfunction* main() {\n  try {\n    yield call(fetchAll)\n  } catch (e) {\n    // handle fetchAll errors\n  }\n}\n")),(0,r.kt)("p",null,"If at a moment, for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll")," is blocked on the ",(0,r.kt)("inlineCode",{parentName:"p"},"delay(1000)")," Effect, and say, ",(0,r.kt)("inlineCode",{parentName:"p"},"task1")," failed, then the whole\n",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll")," task will fail causing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Cancellation of all other pending tasks. This includes:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"main task")," (the body of ",(0,r.kt)("inlineCode",{parentName:"li"},"fetchAll"),"): cancelling it means cancelling the current Effect ",(0,r.kt)("inlineCode",{parentName:"li"},"delay(1000)")),(0,r.kt)("li",{parentName:"ul"},"The other forked tasks which are still pending. i.e. ",(0,r.kt)("inlineCode",{parentName:"li"},"task2")," in our example."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"call(fetchAll)")," will raise itself an error which will be caught in the ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," body of ",(0,r.kt)("inlineCode",{parentName:"p"},"main")))),(0,r.kt)("p",null,"Note we're able to catch the error from ",(0,r.kt)("inlineCode",{parentName:"p"},"call(fetchAll)")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," only because we're using a blocking call. And that\nwe can't catch the error directly from ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchAll"),". This is a rule of thumb, ",(0,r.kt)("strong",{parentName:"p"},"you can't catch errors from forked tasks"),". A failure\nin an attached fork will cause the forking parent to abort (Just like there is no way to catch an error ",(0,r.kt)("em",{parentName:"p"},"inside")," a parallel Effect, only from\noutside by blocking on the parallel Effect)."),(0,r.kt)("h2",{id:"cancellation"},"Cancellation"),(0,r.kt)("p",null,"Cancelling a Saga causes the cancellation of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"main task")," this means cancelling the current Effect where the Saga is blocked")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All attached forks that are still executing"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WIP")),(0,r.kt)("h2",{id:"detached-forks-using-spawn"},"Detached forks (using ",(0,r.kt)("inlineCode",{parentName:"h2"},"spawn"),")"),(0,r.kt)("p",null,"Detached forks live in their own execution context. A parent doesn't wait for detached forks to terminate. Uncaught\nerrors from spawned tasks are not bubbled up to the parent. And cancelling a parent doesn't automatically cancel detached\nforks (you need to cancel them explicitly)."),(0,r.kt)("p",null,"In short, detached forks behave like root Sagas started directly using the ",(0,r.kt)("inlineCode",{parentName:"p"},"middleware.run")," API."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WIP")))}u.isMDXComponent=!0}}]);